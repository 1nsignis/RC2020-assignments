import java.io.*;
import java.net.*;
import java.util.Date;
import java.util.Random;

/** A really simple, lazy and tricky HTTP server supporting ranges
 * 
 * This server accepts a simplified version of range requests
 * if the number of bytes requested is <= than MIN_RANGE
 * it send all the bytes requested.
 * However, if the number of bytes requested is > MIN_RANGE
 * it will send a random number of at most MAX_RANGE
 * The sending bitrate is also random, see below for values.
 * 
 * @author The class instructors
 *
 */


public class HttpTrickyServer {

	static final int DEF_PORT = 8080;

	static final int MAX_RANGE = 10000000; // bytes
	static final int MIN_RANGE =  1000000; // bytes
	static final int MAX_BUFFER = 8192;    // bytes

	static final int TOP_DELAY = 32; // ms -- when growing don't go above this
	static final int MAX_DELAY = 19; // ms -- max starting delay
	// 1/(MAX_DELAY) = 
	static final int MIN_DELAY = 3; // ms
	// 1/(MIN_DELAY) = 

	static Random rand;


	/**
	 * Returns the common part of the reply header
	 * the end of the header (\r\n\r\n) must be generated by the caller
	 */
	private static String serverCommonHeader(String result, String message, int length) {
		return
				"HTTP/1.0 "+result+" "+message+"\r\n" +
				"Date: "+new Date().toString()+"\r\n" +
				"Server: "+"X-Tricky-Server-RC2018"+"\r\n" +
				"Connection: close\r\n" +
				"XAlmost-Accept-Ranges: bytes\r\n" +
				"Content-Length: "+String.valueOf(length)+"\r\n";
	}

	/**
	 * Sends an error message "Not Implemented"
	 */
	private static void sendsNotSupportedPage(OutputStream out) 
			throws IOException {
		String page = 
				"<HTML><BODY>Tricky server: request not supported</BODY></HTML>";
		int length = page.length();
		String header = serverCommonHeader("501","Not Implemented",length);
		header += "Content-type: text/html\r\n\r\n";
		header += page;
		out.write(header.getBytes());
	}

	/**
	 * Sends a Not Found error page with the text of the parameter htmlPage
	 */
	private static void sendsNotFound(String htmlMessage, OutputStream out) 
			throws IOException {
		String page = 
				"<HTML><BODY>Tricky server: "+htmlMessage+"</BODY></HTML>";
		int length = page.length();
		String header = serverCommonHeader("404","Not Found",length);
		header += "Content-type: text/html\r\n\r\n";
		header += page;
		out.write(header.getBytes());
	}



	private static void processClientRequest(Socket s, long delay) {
		try {
			InputStream in = s.getInputStream();
			OutputStream out = s.getOutputStream();
			long[] ranges = { -1,-1 }; // useless but anyway
			String line = Http.readLine(in);
			System.out.println("Got: \n"+line);
			String[] request = Http.parseHttpRequest(line);

			// ignore, but print the header of the http message
			line = Http.readLine(in);
			while ( ! line.equals("") ) {
				System.out.println(line);
				String[] header = Http.parseHttpHeader(line);
				if ( header[0].equalsIgnoreCase("Range") )
					ranges = Http.parseRangeValues(header[1]);
				line = Http.readLine(in);
			}
			System.out.println();

			if( request[0].equalsIgnoreCase("GET") && request[1] != "") {
				sendFile(request[1], ranges, out, delay);
			} else {
				sendsNotSupportedPage(out);
			}
		} catch (IOException e) {
			System.err.println(e.getMessage());
		}
	}


	/**
	 * sendFile: when available, sends the file in the URL to the client
	 * 
	 */
	private static void sendFile(String fileName, long[] ranges,
			OutputStream out, long delay) throws IOException {
		// strips the leading "/"
		String name = fileName.substring(1);
		File f = new File(name);
		System.out.println("Sending file: \""+name+"\"\n");
		if ( name == "" ) sendsNotFound("the empty name is not a file",out);
		else if ( !f.exists() ) sendsNotFound("file \""+fileName+"\" does not exist",out);
		else if ( !f.isFile() ) sendsNotFound("file \""+fileName+"\" is not a file",out);
		else if ( !f.canRead() ) sendsNotFound("file \""+fileName+"\" cannot be read",out);
		else {
			// we are going to send something, lets compute random size and bitrate
			int maxBytes = MIN_RANGE+rand.nextInt(MAX_RANGE-MIN_RANGE+1);

			long fileSize = f.length();
			if (ranges[0]==-1 && ranges[1] == -1 ) { // special case: no ranges 
				ranges[1] = fileSize-1; 
				ranges[0] = 0;
			}
			else if ( ranges[1] == -1 ) { // special case: up to the end of the file
				ranges[1] = fileSize-1;
			}
			long rest = fileSize - ranges[0];     // never sends more then available
			if (rest > maxBytes) rest = maxBytes; // never sends more then maxBytes
			long rangeSize = ranges[1]-ranges[0]+1;
			if (rest >= rangeSize) rest=rangeSize; // never sends more then demanded
			// rest is negative or 0 if fileSize < ranges[0] or if ranges[1] < ranges[0]
			// rest is <= still available && <= MAX_BYTES && <= demanded
			long size = rest <= 0? 0 : rest; // number of bytes to send

			RandomAccessFile file = new RandomAccessFile ( f, "r" );
			StringBuilder header = new StringBuilder("");

			if ( size == 0 ) {
				header.append(serverCommonHeader("416","range not satisfiable",0));
				header.append("Content-Range: bytes */*\r\n\r\n");
				file.close();
				out.write(header.toString().getBytes());
				return;
			}
			// send the all file? it covers the case where a range was asked
			// but all the file is sent (bytes=0-fileSize, bytes=0-, bytes=0-something too big
			else if ( ranges[0]==0 && size == fileSize ) {
				header.append(serverCommonHeader("200","OK",(int) size));
				header.append("\r\n");
			}
			else  { // there are ranges and something to send
				header.append(serverCommonHeader("206","Partial Content", (int) size));
				header.append("Content-Range: bytes "
						+ranges[0]+"-"+(ranges[0]+size-1)+"/"+fileSize+"\r\n\r\n");
			}
			out.write(header.toString().getBytes());
			// size > 0 since there is something to send
			int bufferSize = (size <= MAX_BUFFER) ? (int)size : MAX_BUFFER;
			byte[] buffer = new byte[bufferSize];
			int totalSent = 0;
			file.seek(ranges[0]);

			//System.err.println("IT\t"+delay+"\trange\t"+size);
			//System.err.println("ST\t"+TOP_DELAY);

			//long time0 = System.currentTimeMillis();

			for(;;) {
				int n = file.read(buffer,0,bufferSize);
				if( n == -1) break;
				out.write(buffer, 0, n);

				totalSent += n;
				if ( size - totalSent <= bufferSize ) {
					bufferSize = (int)(size - totalSent);
					if ( rand.nextInt(4)<1 && ranges[0]==0 ) {
						//if first file's reply, last buffer can be lost
						System.err.println("  lost connection");
						break;
					} //else System.err.println("      continuing");
				}
				if ( bufferSize == 0 ) break;
				//if ( totalSent > 1000000 ) randomDelay++;
				if ( totalSent > MIN_RANGE && totalSent%10==0 ) delay++; // depends on MAXBUFFER

				if ( delay > TOP_DELAY ) delay = TOP_DELAY;
				//System.err.println("dt\t"+delay);
				//System.err.println(System.currentTimeMillis()+": delay="+randomDelay);
				try {Thread.sleep((long) delay);} catch (Exception e) {};
			}
			file.close();

			//System.err.print("Sent: "+totalSent+" bytes of "+size);
			//long time = System.currentTimeMillis()-time0;
			//System.err.println(" in "+time+" ms Kbits/s= "+(8*size/(double)time));
		}
	}



	/**
	 * MAIN - accept and handle client connections at a given port
	 */

	public static void main(String[] args) {
		if ( args.length > 1 ) {
			System.err.println("Usage: java HttpTrickyServer [port]");
			System.exit(0);
		}
		long time = System.currentTimeMillis();

		try {
			int port = args.length == 1 ? Integer.parseInt(args[0]) : DEF_PORT;
			ServerSocket ss = new ServerSocket(port);
			rand = new Random();
			// we are going to send something, lets compute base random bitrate
			long randomDelay = MIN_DELAY+rand.nextInt(MAX_DELAY-MIN_DELAY+1);
			long sign = randomDelay>(MAX_DELAY+MIN_DELAY)/2? -1: 1;
			//System.out.println("start delay "+randomDelay+" sign "+sign);
			for (;;) {
				try {
					System.out.println("\nHttp tricky server ready at port "+port+ "; waiting for request ...");
					Socket clientSock = ss.accept();
					processClientRequest( clientSock, randomDelay );
					clientSock.close();

					//if (port!=DEF_PORT) { 
						long t = System.currentTimeMillis();

						if ( t-time > 2500 ) {  // after 2.5s delay will change
							time = t;
							randomDelay = randomDelay +sign;
							if ( randomDelay>=MAX_DELAY ) sign=-1;
							else if (randomDelay<MIN_DELAY) sign=1;
						}
					//}
					//else randomDelay = 1+MIN_DELAY+rand.nextInt(MAX_DELAY-MIN_DELAY+1);
					//System.out.println("     delay "+randomDelay+" sign "+sign);
				} catch (IOException e) {
					System.err.println("client failed");
				}
			}
		} catch (Exception e ) {
			e.printStackTrace();
			System.err.println("\nHttp tricky server is going down.\n");
			System.exit(-1);
		}
	}

}


